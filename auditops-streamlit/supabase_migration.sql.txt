supabase_migration.sql

-- supabase_migration.sql (STEP 2)
-- Creates tables + constraints + indexes for AuditOps
-- RLS + policies will be added in STEP 3

-- Extensions (gen_random_uuid)
create extension if not exists pgcrypto;

-- 1) users_profile
create table if not exists public.users_profile (
  user_id uuid primary key references auth.users(id) on delete cascade,
  full_name text not null,
  role text not null check (role in ('admin','auditor')),
  created_at timestamptz not null default now()
);

-- 2) clients
create table if not exists public.clients (
  client_id uuid primary key default gen_random_uuid(),
  client_name text not null,
  address text,
  notes text,
  active boolean not null default true,
  created_at timestamptz not null default now()
);

-- 3) client_secrets (1:1 with clients)
create table if not exists public.client_secrets (
  client_id uuid primary key references public.clients(client_id) on delete cascade,
  wifi_name text,
  wifi_password text,
  alarm_code text,
  lockbox_code text,
  other_site_notes text,
  updated_at timestamptz not null default now(),
  updated_by uuid references auth.users(id)
);

-- 4) assignments (many-to-many: client <-> auditor)
create table if not exists public.assignments (
  assignment_id uuid primary key default gen_random_uuid(),
  client_id uuid not null references public.clients(client_id) on delete cascade,
  auditor_user_id uuid not null references auth.users(id) on delete cascade,
  active boolean not null default true,
  created_at timestamptz not null default now(),
  constraint assignments_unique unique (client_id, auditor_user_id)
);

-- 5) checkins
create table if not exists public.checkins (
  checkin_id uuid primary key default gen_random_uuid(),
  client_id uuid not null references public.clients(client_id),
  auditor_user_id uuid not null references auth.users(id),
  checkin_at timestamptz not null default now(),
  audit_date date not null,
  rate numeric(10,2) not null default 40.00,
  notes text,
  attachment_path text,
  status text not null default 'submitted' check (status in ('submitted','approved','rejected','paid')),
  reviewed_by uuid references auth.users(id),
  reviewed_at timestamptz,
  rejection_reason text
);

create index if not exists idx_checkins_status on public.checkins(status);
create index if not exists idx_checkins_auditor_date on public.checkins(auditor_user_id, audit_date);
create index if not exists idx_checkins_client_date on public.checkins(client_id, audit_date);

-- 6) pay_periods
create table if not exists public.pay_periods (
  pay_period_id uuid primary key default gen_random_uuid(),
  start_date date not null,
  end_date date not null,
  created_at timestamptz not null default now(),
  created_by uuid references auth.users(id),
  constraint pay_periods_unique unique (start_date, end_date),
  constraint pay_periods_valid_range check (start_date <= end_date)
);

-- 7) statements
create table if not exists public.statements (
  statement_id uuid primary key default gen_random_uuid(),
  pay_period_id uuid not null references public.pay_periods(pay_period_id) on delete cascade,
  auditor_user_id uuid not null references auth.users(id),
  total_amount numeric(10,2) not null default 0.00,
  pdf_path text,
  created_at timestamptz not null default now()
);

create index if not exists idx_statements_auditor on public.statements(auditor_user_id);
create index if not exists idx_statements_pay_period on public.statements(pay_period_id);

-- 8) statement_lines
create table if not exists public.statement_lines (
  statement_line_id uuid primary key default gen_random_uuid(),
  statement_id uuid not null references public.statements(statement_id) on delete cascade,
  checkin_id uuid not null references public.checkins(checkin_id),
  line_amount numeric(10,2) not null,
  constraint statement_lines_unique unique (statement_id, checkin_id)
);

create index if not exists idx_statement_lines_statement on public.statement_lines(statement_id);
create index if not exists idx_statement_lines_checkin on public.statement_lines(checkin_id);

-- 9) secrets_access_log
create table if not exists public.secrets_access_log (
  log_id uuid primary key default gen_random_uuid(),
  client_id uuid not null references public.clients(client_id) on delete cascade,
  auditor_user_id uuid not null references auth.users(id) on delete cascade,
  accessed_at timestamptz not null default now(),
  fields_accessed jsonb not null default '[]'::jsonb,
  reason text
);

create index if not exists idx_secrets_access_log_client on public.secrets_access_log(client_id);
create index if not exists idx_secrets_access_log_auditor on public.secrets_access_log(auditor_user_id);
create index if not exists idx_secrets_access_log_accessed_at on public.secrets_access_log(accessed_at);
